---
title: "Operating Systems and Kernel"
layout: single
categories:
  - Operating Systems
  - Kernel
permalink: /os/kernel/0/
last_modified_at: 2022-03-06T14:44:00+09:00

---

## Operating Systems

OS는 유저와 하드웨어 리소스 사이의 abstraction으로서, 효율적으로 하드웨어 리소스를 보호하고 관리하는 동시에 유저에게 이에 대한 편리한 인터페이스를 제공한다.

## OS Roles

OS는 제한된 자원을 효율적으로 배분하고 보호하기 위한 역할을 한다.

### Referee

하드웨어에 대한 온전한 제어권은 오로지 OS만 가지며, 유저 어플리케이션이 하드웨어 리소스를 필요로 할 경우 OS에 요청하게 된다.
이처럼 하드웨어에 대한 중앙화된 관리 형태는 여러 어플리케이션들이 **효율적으로 자원을 나눠가질 수 있게 하고**,
**서로에게 영향을 끼칠 수 없도록 고립시키는** 동시에 **서로간의 커뮤니케이션을 가능하게 한다**.

OS의 이런 역할이 없다면 발생할 수 있는 문제는 무엇이 있을까?? 가장 쉽게 생각할 수 있는 예시로, 디스플레이에 대한 제어권을 온전히 가진 어플리케이션을 생각해보자.
이 어플리케이션은 다른 어플리케이션의 디스플레이 출력 위에 강제로 다른 출력을 덮어씌움으로써 어플리케이션의 정상적인 동작을 방해할 수 있다.
다른 예시로는 한 어플리케이션이 DRAM을 쓰레기 데이터로 가득 채워버리거나 다른 어플리케이션의 메모리 영역을 침범함으로써 그 어플리케이션에 심각한 장애를 유발할 수 있다.

이처럼 하드웨어에 대한 관리를 OS에 전적으로 위임함으로서 어플리케이션이 하드웨어를 악용하는 사례를 방지할 수 있다.

또 다른 문제로는 여러 어플리케이션이 동시에 동작할 때, 한정된 자원들을 적절히 배분하는 자원 배분 정책의 문제가 항상 발생한다.
이를 OS가 담당하는데, 유저 어플리케이션에게 맡기게 된다면 한 어플리케이션이 자원을 독점하는 일이 발생할 수 있어 다른 어플리케이션의 정상적인 동작을 방해할 수 있다.

### Illusionist

OS abstraction은 각 유저 어플리케이션이 무한한 자원을 독점적으로 사용하는 것처럼 보이게 한다.
예를 들어, OS가 제공하는 **Virtual Memory** abstraction은 모든 어플리케이션이 메모리 전체를 홀로 사용하는 것처럼 보이게 한다.
또 다른 예시로, Multiprocessing / Multithreading application은 thread나 process의 개수에 제한이 없어 마치 무한개의 cpu core를 사용하는 것처럼 보이게 한다.

### Glue

마지막으로, OS는 user level에서 하드웨어에 대한 high-level abstraction을 제공한다.
예를 들어 OS에서 제공하는 GNU C Library의 `printf`, `scanf` 등의 함수들은 user가 하드웨어에 대한 지식 없이도 편리하게 입출력을 처리할 수 있도록 도와준다.

## OS Challenges

OS가 위에서 언급한 역할들을 잘 수행하기 위해서 풀어야 하는 문제들은 다음과 같다.

### Reliability

OS는 최초 디자인된 목적에 걸맞는 역할을 수행할 수 있어야 한다.

### Availability

OS가 실제로 잘 작동하는 시간을 최대화시켜야 한다.

- MTTF(Mean Time To Failure): 시스템 실패가 발생하는데 걸리는 평균 시간
- MTTR(Mean Time To Repair): 시스템 실패로부터 복구하는데 걸리는 평균 시간

### Security

OS는 외부 공격으로부터 하드웨어 리소스를 안전하게 지킬 수 있어야 한다.

### Privacy

OS가 관리하는 데이터는 아무나 접근할 수 없어야 한다.

### Portability

OS는 범용적인 인터페이스를 제공해야 한다.

- For User(API): 유저는 어플리케이션을 제작할 때 OS에 무관하게 제작할 수 있어야 한다. 즉, OS들은 표준 인터페이스를 제공하는 것을 지향한다.
- For OS(HAL): OS는 동시에 하드웨어에 대한 표준 인터페이스를 제공받아야 한다. 즉, 하드웨어들은 OS에서 요구하는 표준 인터페이스를 준수하도록 설계하는 것을 지향한다.

### Performance

OS 성능에 직결되는 부분들이다.

- Latency / Response Time: 연산이 수행되는데 걸리는 시간이 짧을수록 좋다.
- Throughput: 단위 시간동안 수행할 수 있는 연산의 양이 많을수록 좋다.
- Overhead: 연산을 수행하는데 OS가 수행해야 할 추가적인 일의 양이 적을수록 좋다.
- Fairness: 모든 어플리케이션에게 공평할수록 좋다.
- Predictability: OS 성능이 일관적일수록 좋다.

## Kernel

Kernel은 OS를 구성하는 핵심 프로그램으로, 시스템 및 하드웨어에 대한 온전한 통제권을 가진 유일한 프로그램이다.
컴퓨터가 작동하는 내내 실행되는 프로그램이며, 다른 프로그램들은 시스템 프로그램이거나 어플리케이션 프로그램이다.

컴퓨터가 신뢰할 수 있는 유일한 프로그램은 kernel 뿐이며, OS는 신뢰할 수 없는 다른 코드들로부터 kernel을 보호하기 위해 메모리 공간을 분리하고, mode를 구분한다.

### Privileged Instructions

다음과 같은 작업들은 당연하게도 privileged instruction들이어야 한다.

- Change the privilege level(mode bit)
- Adjust access control level

이처럼 유저 어플리케이션이 수행할 수 없어야 하는, kernel만이 수행할 수 있는 instruction들이 privileged instruction들이다.

### Kernel Space vs. User Space

모든 user application(process)의 address space는 Kernel Space와 User Space로 나눌 수 있다.

- Kernel Space: 보호된 memory space이자, 하드웨어에 대한 모든 권한을 가지고 있다. 커널 코드와 데이터만 들어간다.
- User Space: kernel space를 제외한 memory space로, 해당 application이 가진 권한 내에서만 하드웨어에 접근할 수 있다.

### Kernel Mode vs. User Mode

하드웨어 레지스터에 저장된 mode bit에 따라 kernel mode와 user mode가 구분된다.
Kernel mode에서는 privileged instruction을 실행할 수 있지만, user mode에서는 불가능하다.

<br>

다음 글: [Mode Switch](/os/kernel/1/)

모든 글: [Kernel](/os/kernel/) [Operating Systems](/os/)
